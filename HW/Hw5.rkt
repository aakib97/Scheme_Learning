#lang racket
;;Problem 1
(define (max f g)
 (lambda (x)
  (if (< (f x) (g x))
      (f x)
      (g x)
  )
 )
)
(define (f1 x) x)
(define (g1 x) - x)
((max f1 g1)2)
;returns 2

;;Problem 2
(define (zip a b)
 (if (null? (and a b))
     '()
     (cons (list (car a) (car b)) (zip (cdr a) (cdr b)))
 )
)
(define list1 (list 1 2 3))
(define list2 (list 4 5 6))
(zip list1 list2)
;returns ((1 . 4) (2 . 5) (3 . 6))
(define list3 (list 12 5 8))
(define list4 (list 3 18 6))
(zip list3 list4)
;returns ((12 . 3) (5 . 18) (8 . 6))

;;Probelm 3
(define (listpair1 l)
 (if (null? l)
     '()
     (if (null? (cdr l))
         (append '() l)
         (cons (car l) (listpair1 (cdr (cdr l))))
     )
 )
)
(define (listpair2 l)
 (if (null? l)
     '()
     (if (null? (cdr l))
         '()
         (cons (car (cdr l)) (listpair2 (cdr (cdr l))))
     )
 )
)
(define (unzip l)
 (if (null? l)
     '()
  (list (listpair1 l) (listpair2 l))
 )
)

(unzip '(1 2 3 4 5 6 7 8))
;returns ((1 3 5 7) (2 4 6 8))
(unzip '(1 2 3 4 6))
;returns ((1 3 6) (2 4))

;;Problem 4
(define (change k l)
 (cond ((= k 0) 1)
        ((or (< k 0) (null? l)) 0)
        (else(+ (change k (cdr l))(change (- k (car l)) l)))
 )
)
(change 10 '(5 1))
;returns 3
(change 10 '(1 5 10 25))
;returns 4

;;Problem 5
;a
(define (encode p)
 (let ((x (car p))
       (y (cdr p)))
       (+(*(*(/ 1 2)(+ x y))(+ (+ x y) 1))y)
     
 )
)
(define p1 (cons 5 2))
(encode p1)
(define p2 (cons 1 2))
(encode p2)
;b
(define (xy-value z)
 (let* ((w (floor (/(-(sqrt (+ (* 8 z) 1))1)2)))
        (t (floor (/ (+ (* w w) w)2)))
        (y (- z t))
        (x (- w y)))
        (cons x y)
 )
)
(xy-value 30)
;returns 5 2, which is true from part a

;;Problem 6
(define (post-test l)
 (if (null? l)
     '()
     (if (> (car l) 0)
         (cons (car l) (post-test (cdr l)))
         (post-test (cdr l))
     )
 )
)
(define (positives l)(post-test l))

(positives (list -2 -1 0 1 2))
;returns (1 2)
(positives (list 2 1 0 -2 -1))
;returns (2 1)
(positives (list 3 1 -1 1 -1))
;returns (3 1 1)

;;Problem 7
(define (remove-v v l)
 (if (null? l)
     l
     (if (equal? v (car l))
         (remove-v v (cdr l))
         (cons (car l)(remove v (cdr l)))
      )
 )
)
(define (remove-duplicates l)
 (if (null? l)
     '()
     (cons (car l)(remove-duplicates (remove-v (car l) (cdr l))))
 )
)

(remove-duplicates (list 6 5 8 5 6 5))
;returns (6 5 8)
(remove-duplicates '(1 6 1 1 1 5 6 8 8 3 3 9 9 5))
;returns (1 6 1 5 8 3 9)
(remove-duplicates '(5 5 5 5 6 6 6 6 8 8 8 8 8))
;returns (5 6 8)